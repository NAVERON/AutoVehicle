# AutoNavVehicle

> Secrecy Project

# Frame Design

## Navigator Class Design

| 类别   | 航行器      | 船舶          |
| ---- | -------- | ----------- |
| 静态属性 | idNumber |             |
|      | name     |             |
|      | longth   |             |
|      | width    |             |
|      | type     |             |
|      |          | imoNumber   |
|      |          | callNumber  |
|      |          | destination |
|      |          | expTime     |
| 动态属性 | 船首朝向     | head        |
|      | 航向       | course      |
|      | 速度       | speed       |
|      | 纬度       | latitude    |
|      | 经度       | longitude   |
|      | 状态       | state       |
|      | 最近更新时间   | updateTime  |

## 通信协议的设计

当本航行器遇到无法行动的困境时：分析后没有解，则需要向周边发送本航行器的航行状态，告知周边本航行器无法判断

**本航行器将做出如下动作：**

- 保持航行状态，并向周边发送协商请求
- 周边航行器收到群发消息后，分析与本航行器的关系，对保持对象发送本航行器做出的决策
- 本航行器收到其它的信号后，（信号中只包含与本航行器会遇状态，从左舷通过还是右舷通过），本航行器对应的分析是否可以协调
- 本航行器最后如果能得到可行解，则群发确认
- 如果还是不可行，则选取一个进行单独协商（程序上好像不太好实现）

还是很不完善，以后补充

协商过程如何进行，如何终止，如何算是成功的协商，如何算是正确的结果？如何保证最终得到解，得不到解怎么办？

//Test


# 兼容分析

## 如何制定避碰规则

制定的避碰规则应当保证能够兼容，在情况变化时，能够继续上次的判断，保证在边界不造成来回的决策摆动

## 碰撞测试

设计需要测试哪几种情况，就可以保证无人航行器在这几种情况下能够避障，就一定可以在任何情况下进行避碰

## 可行操作

避碰判断结果包括调控**速度**和**航向**
判断过程应当是阶段性的，而不是瞬时的，瞬时的判断应当存储，比较下一次的判断，形成一个判断链，每次分析判断结果的变化，推测以后的变化









